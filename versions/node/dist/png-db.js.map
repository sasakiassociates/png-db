{"version":3,"file":null,"sources":["../../../src/FieldTypes.js","../../../src/PngDB.js","../../../src/PngDBReader.js","../../../src/PngDBWriter.js"],"sourcesContent":["'use strict';\nclass FieldTypes {\n    constructor(name) {\n        this.name = name;\n    }\n\n    toString() {\n        return `FieldTypes.${this.name}`;\n    }\n\n    static isNumeric(name) {\n        return name === FieldTypes.INTEGER.name\n            || name === FieldTypes.DECIMAL.name;\n    }\n}\n\n/**\n * KEY values are stored as a flat JSON array with no compression. Use sparingly.\n * @type {FieldTypes}\n */\nFieldTypes.KEY = new FieldTypes('KEY');\n\n/**\n * TEXT values are stored as indexed values using an integer. The index (text strings for each integer) is stored in the main json file. Don't use this for primary keys or other values that don't repeat much.\n * @type {FieldTypes}\n */\nFieldTypes.TEXT = new FieldTypes('TEXT');\n\n/**\n * decimals are stored as integers representing the offset minimum value for each field and a multiplier for precision\n * @type {FieldTypes}\n */\nFieldTypes.DECIMAL = new FieldTypes('DECIMAL');\n\n/**\n * (3 bytes) up to 16,777,215 values\n * @type {FieldTypes}\n */\nFieldTypes.INTEGER = new FieldTypes('INTEGER');\n\nexport default FieldTypes;","import FieldTypes from \"./FieldTypes\";\n\n'use strict';\n/**\n * Node.js class for writing databases\n */\nexport default class PngDB {\n\n    constructor() {\n        this.fields = {};\n        this.metadata = {};\n        this.records = [];\n    }\n\n    /**\n     * Add a field to the database\n     * @param {String} fieldName (any string)\n     * @param {FieldTypes} type\n     * @param {Object} [opts] - field options\n     */\n    addField(fieldName, type, opts = {}) {\n        var ft = new FieldTypes();\n        this.fields[fieldName] = {type: type.name};\n\n        this.fields[fieldName].buckets = {\n            count: 0,\n            ...opts.buckets,\n        };\n\n        if ('precision' in opts) {\n            this.fields[fieldName].precision = opts.precision;\n        }\n    }\n\n    /**\n     * Add an Array field to the database. Arrays are represented as a large images tiled together.\n     * @param {String} fieldName (any string)\n     * @param {FieldTypes} type\n     * @param {Object} [opts] - field options\n     */\n    addArrayField(fieldName, type, opts = {}) {\n        this.addField(fieldName, type, opts);\n        this.fields[fieldName].treatAsArray = true;\n    }\n\n    /**\n     * add any metadata to be stored as JSON\n     * @param {String} key\n     * @param {Object} value\n     */\n    addMetaData(key, value) {\n        this.metadata[key] = value;\n    }\n\n    /**\n     * add a record object - object properties must match field names exactly\n     * @param {Object} record\n     */\n    addRecord(record) {\n        // console.log('Add record');\n        this.records.push(record);\n    }\n\n    _shiftBits(number, columns) {\n        if (!number) number = 0;\n        if (columns === 0) return number;\n        if (columns === 1) return number << 8;\n        if (columns === 2) return number << 16;\n        if (columns === 3) return number << 32;\n    }\n\n    _encodeFields(record, field1, field2) {\n        //(0x6633 << 16 | 0x3399).toString(16)\n        return this._shiftBits(record[field1], 2) | record[field2];\n    }\n}\n","import FieldTypes from \"./FieldTypes\";\nimport PngDB from \"./PngDB\";\n\n// var getPixels = require(\"get-pixels\");\n\n'use strict';\n/**\n * Node.js class for writing databases\n */\nexport default class PngDBReader extends PngDB {\n\n    constructor() {\n        super();\n        this.url = null;\n        this.cacheTime = new Date().getTime();\n    }\n\n    _getDir(url) {\n        const bits = url.split('/');\n        bits.pop();\n        return bits.join('/');\n    }\n\n    _getJSON(url) {\n        const xhr = new XMLHttpRequest();\n        return new Promise((resolve, reject) => {\n            xhr.onreadystatechange = function () {\n                if (xhr.readyState === 4) {\n                    if (xhr.status === 200) {\n                        resolve(JSON.parse(xhr.responseText));\n                    } else {\n                        reject(xhr.responseText);\n                    }\n                }\n            };\n            xhr.open('GET', url);\n            xhr.send();\n        });\n    }\n\n    load(url) {\n        this.url = url;\n        return new Promise((resolve, reject) => {\n            this._getJSON(url).then((data) => {\n                this.metadata = data.metadata;\n                this.fields = data.fields;\n                this.imageSize = data.imageSize;\n                this.records = [];\n                for (let i = 0; i < data.recordCount; i++) {\n                    this.records.push({});//empty for now, but will be populated when fields are loaded\n                }\n                resolve();\n            }, function (err) {\n                reject(err);\n            })\n        });\n    }\n\n    loadImagePixels(url, cb) {\n        const img = new Image();\n        img.crossOrigin = \"Anonymous\";\n        img.onload = function () {\n            const canvas = document.createElement('canvas');\n            canvas.width = img.width;\n            canvas.height = img.height;\n            const context = canvas.getContext('2d');\n            context.drawImage(img, 0, 0);\n            const imageData = context.getImageData(0, 0, img.width, img.height);\n            cb(null, imageData.data);// ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4*img.width, 1], 0))\n        };\n        img.onerror = function (err) {\n            cb(err)\n        };\n        console.log('Loading Image: ' + url);\n        img.src = url;\n    }\n\n    loadFields(fieldNames, forceRefresh) {\n        return new Promise((resolve, reject) => {\n            const calls = [];\n            fieldNames.forEach((fieldName, i) => {\n                calls.push(this.loadField(fieldName, forceRefresh));\n            });\n            Promise.all(calls)\n                .then(function (results) {\n                    resolve();\n                });\n        });\n    }\n\n    loadField(fieldName, forceRefresh) {\n        if (!this.url) throw 'Please load the database first';\n        let field = this.fields[fieldName];\n        if (!field) throw 'Unknown field ' + fieldName;\n\n        const dir = this._getDir(this.url);\n        return new Promise((resolve, reject) => {\n            if (field.dataLoaded && !forceRefresh) {\n                resolve();\n                return;\n            }\n            if (field.type === FieldTypes.KEY.name) {\n                this._getJSON(`${dir}/${encodeURIComponent(fieldName)}.json`).then((data) => {\n                    for (let i = 0; i < this.records.length; i++) {\n                        this.records[i][fieldName] = data[i];\n                    }\n                    field.dataLoaded = true;\n                    resolve();\n                }, function (err) {\n                    reject(err);\n                });\n                return;\n            }\n            this.loadImagePixels(`${dir}/${encodeURIComponent(fieldName)}.png?ac=${this.cacheTime}`, (err, pixels) => {\n                if (err) {\n                    reject(\"Bad image path: \" + err);\n                    return;\n                }\n\n                const valFromPixel = (pos) => {\n                    const a = pixels[pos + 3];\n                    if (a === 0) return null;\n\n                    const r = pixels[pos];\n                    const g = pixels[pos + 1];\n                    const b = pixels[pos + 2];\n\n                    let val = r << 16 | g << 8 | b;\n\n                    if (field.uniqueValues) {\n                        val = field.uniqueValues[val];\n                    } else {\n                        if (field.precision) {\n                            val /= field.precision;\n                        }\n\n                        if (field.range) {\n                            val += field.range.min;// we store the offset from the min value for smaller integers and also to allow signed values with the same methodology\n                        }\n                    }\n                    return val;\n                };\n\n                field.dataLoaded = true;\n                let val = null;\n                if (field.treatAsArray) {\n                    const numTilesEach = Math.ceil(Math.sqrt(field.longestArray));\n                    const pxSize = this.imageSize.width;\n                    const imgSize = pxSize * numTilesEach;\n                    let i = 0;\n                    for (let y = 0; y < pxSize; y++) {\n                        for (let x = 0; x < pxSize; x++) {\n                            const arr = [];\n                            for (let ty = 0; ty < numTilesEach; ty++) {\n                                for (let tx = 0; tx < numTilesEach; tx++) {\n                                    const xPos = tx * pxSize + x;\n                                    const yPos = ty * pxSize + y;\n                                    const pos = yPos * (imgSize * 4) + xPos * 4;\n\n                                    let val = valFromPixel(pos);\n                                    if (val !== null) {\n                                        arr.push(val);\n                                    }\n                                }\n                            }\n                            if (i < this.records.length) {\n                                this.records[i][fieldName] = arr;\n                            }\n                            i++;\n                        }\n                    }\n                } else {\n                    for (let i = 0; i < this.records.length; i++) {\n                        const pos = i * 4;\n                        val = valFromPixel(pos);\n                        this.records[i][fieldName] = val;\n                    }\n                }\n\n                resolve();\n            })\n        });\n    }\n\n    loadAllRecordsFromJson(url) {\n        this.url = url;\n        return new Promise((resolve, reject) => {\n            this._getJSON(url).then((data) => {\n                this.metadata = data.metadata;\n                this.fields = data.fields;\n                this.records = data.records;\n\n                Object.keys(this.fields).forEach((fieldName) => {\n                    const field = this.fields[fieldName];\n                    field.dataLoaded = true;\n                });\n                resolve();\n            }, function (err) {\n                reject(err);\n            })\n        });\n    }\n}","import fs from 'fs';\nimport path from 'path';\nimport Jimp from 'jimp';\n\nimport PngDB from \"./PngDB\";\nimport FieldTypes from \"./FieldTypes\";\n\n'use strict';\n\nconst isVal = x => typeof x !== 'undefined' && x !== null && !isNaN(x);\n\n\n/**\n * Node.js class for writing databases\n */\nexport default class PngDBWriter extends PngDB {\n\n    constructor({quantiles = 0} = {}) {\n        super();\n\n        this.MAX_VALUE = 255 * 256 * 256 - 1;\n        this.stats = {\n            quantiles, //e.g. use 4 for 'quartiles' (25th percentile, 50th percentile etc)\n        };\n    }\n\n    save(saveAs) {\n        try {\n            const size = this.records.length;\n            const pxSize = Math.ceil(Math.sqrt(size));\n\n            console.log(`Saving ${size} records (width = ${pxSize}) ...`);\n\n            const dir = path.dirname(saveAs);\n\n            if (!fs.existsSync(dir)) {\n                console.log(`Making dir ${dir} ...`);\n                fs.mkdirSync(dir);\n            }\n\n            Object.keys(this.fields).forEach((k) => {\n                const field = this.fields[k];\n                if (field.type === FieldTypes.TEXT.name) {\n                    field.uniqueValues = [];\n                }\n                if (!FieldTypes.isNumeric(field.type)) return;\n                field.range = {min: Number.MAX_VALUE, max: -Number.MAX_VALUE};\n            });\n\n            const sortedValues = {};\n\n            this.records.forEach((record, i) => {\n                Object.keys(this.fields).forEach((k) => {\n                    const field = this.fields[k];\n                    let value = record[k];\n                    if (this.stats.quantiles > 1 || field.buckets.count > 1) {\n                        if (!sortedValues[k]) sortedValues[k] = [];\n                        sortedValues[k].push(value);\n                    }\n                    if (field.range) {\n                        if (field.treatAsArray) {\n                            if (value && value.length > 0) {\n                                for (let j = 0; j < value.length; j++) {\n                                    const v = value[j];\n\n                                    if (isVal(v)) {\n                                        field.range.min = Math.min(field.range.min, v);\n                                        field.range.max = Math.max(field.range.max, v);\n                                    }\n                                }\n                            }\n                        } else {\n                            if (isVal(value)) {\n                                field.range.min = Math.min(field.range.min, value);\n                                field.range.max = Math.max(field.range.max, value);\n                            }\n                        }\n\n                    }\n                    if (field.uniqueValues && field.uniqueValues.indexOf(value) < 0) {\n                        field.uniqueValues.push(value);\n                    }\n                });\n            });\n\n            let sortNumber = (a, b) => {\n                return a - b;\n            };\n\n            Object.keys(this.fields).forEach((k) => {\n                const field = this.fields[k];\n                if (field.range && field.range.max > this.MAX_VALUE) {\n                    field.precision = (this.MAX_VALUE - 1) / field.range.max;//use -1 to prevent floating point errors exceeding\n                }\n\n                const generateQuantiles = field.range && !field.treatAsArray && this.stats.quantiles > 1;\n                const generateBuckets = field.range && !field.treatAsArray && field.buckets.count > 1;\n\n                if (generateQuantiles || generateBuckets) {\n                    sortedValues[k].sort(sortNumber);\n                }\n\n                if (generateQuantiles) {\n                    field.quantiles = [];\n                    for (let i = 1; i < this.stats.quantiles; i++) {\n                        let frac = i / this.stats.quantiles;\n                        let pos = Math.round(frac * sortedValues[k].length);\n                        field.quantiles.push({\n                            position: 100 * frac,\n                            value: sortedValues[k][pos],\n                        });\n                    }\n                }\n\n                if (generateBuckets) {\n                    const buckets = [];\n\n                    const min = 'min' in field.buckets ? field.buckets.min : field.range.min;\n                    const max = 'max' in field.buckets ? field.buckets.max : field.range.max;\n                    const range = max - min;\n                    const size = range / field.buckets.count;\n\n                    for (let i = 0; i <= field.buckets.count; i++) {\n                        buckets.push({\n                            quantity: 0,\n                            range: {\n                                min: (i * size) + min,\n                                max: ((i + 1) * size) + min,\n                            }\n                        });\n                    }\n\n                    const supraMinBucket = {\n                        quantity: 0,\n                        range: {\n                            min: -Infinity,\n                            max: min,\n                        },\n                    };\n                    const superMaxBucket = {\n                        quantity: 0,\n                        range: {\n                            min: max,\n                            max: Infinity,\n                        },\n                    };\n\n                    sortedValues[k].forEach(val => {\n                        if (val > max) {\n                            superMaxBucket.quantity++;\n                        }\n                        else if (val < min) {\n                            supraMinBucket.quantity++;\n                        }\n                        else {\n                            buckets.some((bucket, i) => {\n                                if (bucket.range.min >= val && buckets[i - 1]) {\n                                    if (buckets[i - 1]) {\n                                        buckets[i - 1].quantity++;\n                                    }\n\n                                    return true;\n                                }\n                            });\n                        }\n                    });\n\n                    // Since we aggregate i - 1 to exclude values below the min, we only needed\n                    // the extra bucket for aggregating values into the actual last bucket.\n                    buckets.pop();\n                    if (supraMinBucket.quantity > 0 || superMaxBucket.quantity > 0) {\n                        field.gutterBuckets = {};\n                    }\n                    if (supraMinBucket.quantity > 0) {\n                        field.gutterBuckets.min = supraMinBucket;\n                    }\n                    if (superMaxBucket.quantity > 0) {\n                        field.gutterBuckets.max = superMaxBucket;\n                    }\n\n                    field.buckets = buckets;\n                }\n                else {\n                    delete field.buckets;\n                }\n            });\n\n            const metaDataFile = {\n                metadata: this.metadata,\n                fields: this.fields,\n                recordCount: size,\n                imageSize: {width: pxSize, height: pxSize}\n            };\n\n            Object.keys(this.fields).forEach((fieldName) => {\n                const field = this.fields[fieldName];\n                if (field.type === FieldTypes.KEY.name) {\n                    this.writeKeyData(dir, fieldName, field);\n                } else {\n                    this.writePngData(dir, fieldName, field, pxSize);\n                }\n            });\n\n            fs.writeFile(saveAs, JSON.stringify(metaDataFile, null, 2), (err) => {\n                if (err) throw err;\n                console.log('Saved ' + saveAs);\n            });\n        } catch (e) {\n            console.error(e, e.stack);//for some reason errors aren't always reported in Node.js so we catch and report them here\n        }\n    }\n\n    writeKeyData(dir, fieldName, field) {\n        const recordKeys = [];\n        const fileName = `${fieldName}.json`;\n        this.records.forEach(function (record, i) {\n            recordKeys.push(record[fieldName]);\n        });\n        fs.writeFile(path.join(dir, fileName), JSON.stringify(recordKeys), (err) => {\n            if (err) throw err;\n            console.log('Saved ' + fileName);\n        });\n    }\n\n    writePngData(dir, fieldName, field, pxSize) {\n        let imgSize = pxSize;\n        let numTilesEach = 0;\n        if (field.treatAsArray) {\n            let maxLen = 0;\n            for (let i = 0; i < this.records.length; i++) {\n                const record = this.records[i++];\n                const arr = record[fieldName];\n\n                if (arr != null) {\n                    if (!Array.isArray(arr)) {\n                        throw `Array value expected on record ${i}: Found ${arr}`;\n                    }\n                    maxLen = Math.max(maxLen, arr.length);\n                }\n            }\n            field.longestArray = maxLen;\n            numTilesEach = Math.ceil(Math.sqrt(maxLen));\n            imgSize = pxSize * numTilesEach;\n        }\n\n        const setPixel = (image, x, y, value) => {\n            if (field.range) {\n                value = value - field.range.min;//store the offset from the min value for smaller integers and also to allow signed values with the same methodology\n            }\n            if (field.precision) {\n                value = Math.round(value * field.precision);\n            } else {\n                value = Math.round(value);\n            }\n            if (value > this.MAX_VALUE) {\n                console.warn(`Maximum value exceeded for ${fieldName}: ${value} (TRUNCATED)`);\n                value = this.MAX_VALUE;\n            }\n            let encodedValue = 0;\n            if (value > 255) {\n                let r = 0;\n                const b = value % 256;\n                let g = Math.floor(value / 256);\n\n                if (g > 255) {\n                    r = Math.floor(g / 256);\n                    g = g % 256;\n                }\n                encodedValue = Jimp.rgbaToInt(r, g, b, 255);\n            } else {\n                encodedValue = Jimp.rgbaToInt(0, 0, value, 255);\n            }\n            image.setPixelColor(encodedValue, x, y);\n        };\n\n        new Jimp(imgSize, imgSize, (err, image) => {\n            if (field.treatAsArray) {\n\n                let i = 0;\n                for (let y = 0; y < pxSize; y++) {\n                    for (let x = 0; x < pxSize; x++) {\n                        const record = this.records[i++];\n                        if (!record) continue;\n                        const arr = record[fieldName];\n                        if (!arr) return;\n                        let a = 0;\n                        for (let ty = 0; ty < numTilesEach; ty++) {\n                            for (let tx = 0; tx < numTilesEach; tx++) {\n                                if (a < arr.length) {\n                                    const value = arr[a];\n                                    if (isVal(value)) {\n                                        setPixel(image, tx * pxSize + x, ty * pxSize + y, value);\n                                    }\n                                }\n                                a++;\n                            }\n                        }\n                    }\n                }\n            } else {\n                let i = 0;\n                for (let y = 0; y < pxSize; y++) {\n                    for (let x = 0; x < pxSize; x++) {\n                        const record = this.records[i++];\n                        if (!record) continue;\n                        let value = 0;\n                        if (field.uniqueValues) {\n                            value = field.uniqueValues.indexOf(record[fieldName]);\n                        } else {\n                            value = record[fieldName];\n                        }\n\n                        if (isVal(value)) {\n                            setPixel(image, x, y, value);\n                        }\n                    }\n                }\n            }\n            const fileName = `${fieldName}.png`;\n            image.write(path.join(dir, fileName));\n            console.log(`${fileName} saved`);\n        });\n    }\n\n    /**\n     * Use this method to provide an alternative way to load and save data (as JSON)\n     * @param saveAs\n     */\n    saveAllRecordsAsJson(saveAs) {\n        const fullDataFile = {\n            metadata: this.metadata,\n            fields: this.fields,\n            records: this.records\n        };\n\n        fs.writeFile(saveAs, JSON.stringify(fullDataFile, null, 2), (err) => {\n            if (err) throw err;\n            console.log('Saved ' + saveAs);\n        });\n    }\n\n}\n"],"names":["FieldTypes","name","INTEGER","DECIMAL","KEY","TEXT","PngDB","fields","metadata","records","fieldName","type","opts","ft","buckets","precision","addField","treatAsArray","key","value","record","push","number","columns","field1","field2","_shiftBits","PngDBReader","url","cacheTime","Date","getTime","bits","split","pop","join","xhr","XMLHttpRequest","Promise","resolve","reject","onreadystatechange","readyState","status","JSON","parse","responseText","open","send","_getJSON","then","data","imageSize","i","recordCount","err","cb","img","Image","crossOrigin","onload","canvas","document","createElement","width","height","context","getContext","drawImage","imageData","getImageData","onerror","log","src","fieldNames","forceRefresh","calls","forEach","loadField","all","results","field","dir","_getDir","dataLoaded","encodeURIComponent","length","loadImagePixels","pixels","valFromPixel","pos","a","r","g","b","val","uniqueValues","range","min","numTilesEach","Math","ceil","sqrt","longestArray","pxSize","imgSize","y","x","arr","ty","tx","xPos","yPos","keys","isVal","isNaN","PngDBWriter","quantiles","MAX_VALUE","stats","saveAs","size","path","dirname","fs","existsSync","mkdirSync","k","isNumeric","Number","max","sortedValues","count","j","v","indexOf","sortNumber","generateQuantiles","generateBuckets","sort","frac","round","supraMinBucket","Infinity","superMaxBucket","quantity","some","bucket","gutterBuckets","metaDataFile","writeKeyData","writePngData","writeFile","stringify","e","error","stack","recordKeys","fileName","maxLen","Array","isArray","setPixel","image","warn","encodedValue","floor","Jimp","rgbaToInt","setPixelColor","write","fullDataFile"],"mappings":"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"}